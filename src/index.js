import React from 'react';
import ReactDOM from 'react-dom';
import { createStore } from 'redux';
import {connect, Provider} from 'react-redux';
import App from './components/app';
import reducer from './reducer';
import * as actions from "./actions";
import {bindActionCreators} from "redux/index";

const store = createStore(reducer);

ReactDOM.render( //оборачиваем все приложение в провайдер (из реакт-редакс, похож на тот что из контекст) и указываем какой store мы будем использовать
  <Provider store={store}>
    <App/>
  </Provider>,
  document.getElementById('root'));

/*104 Введение в Redux
>Redux решает проблему управления состоянием в приложении.
>Redux предлагает хранить state в одном "глобальном" объекте.
>Функция Reducer обновляет глобальный state в ответ на Actions (действия).
>Объект Store координирует обновления.
 */

/*105 Создаем новый проект
Для работы с Redux нам понадобится две библиотеки:
redux - сам Redux
react-redux - библиотека, которая упрощает интеграцию между React и Redux.
 */

/*106 Reducer
Reducer это обычная функция:
(state, action) => newState
Если state - undefined, то нужно вернуть первоначальный (initial) state.
Если тип action неизвестен - нужно вернуть state без изменений.

Reducer - это функция, которая получает 2 значения - 1) текущее состояние 2) действие, которое нам нужно совершить. action - это обычный объект у которого есть тип. мы можем проверить тип и взависимости от типа выполнить какое-либо действие. Если мы получили action тип которого мы не знаем - мы не должны трогать тот стейт, который получили. То есть мы его возвращаем в том виде в каком мы его получили.
Если стейт - undefined, то мы должны вернуть первоначальное значение initialState
Каноничный Reducer
const reducer = (state = 0, action) => { //принимает на вход текущий state, вторым аргументом принимает action, возвращает новый стейт по аналогии с setState в реакте
 //присвоили значение по умолчанию к ферстстэйту = 0, так он вернется автоматически с правильным значением из блока default

switch (action.type) {//если наше действие 'INC' - вернуть state +1
    case 'INC':
        return state + 1;

    default: //если не распознали действие возвращаем state и его не изменяем
        return state;
}
};

let state = reducer(undefined, {}); //инициализируем первоначальный стэйт, указывая undefined и пустое действие (не важно какое мы укажем, главное чтобы не из известных действий)

state = reducer(state, { type: 'INC' }); //вызываем функцию reducer, передаем туда предыдущий state, говорим что хотим выполнить действие с типом инкремент ('INC')
//когда мы работаем с redux, action - самый обычный JS объект, у него может быть любая структура, но главное чтобы у него было поле type и у этого поля было какое-либо значение, строка, которая описывает тип действия, которое мы пытаемся совершить.
console.log(state);

state = reducer(state, { type: 'INC' });
console.log(state);
 */

/*107 Redux Store
>Store координирует работу с данными в Redux приложении.
const store = createStore(reducer);

//получать нотификации об изменениях:
store.subscribe(() => //...do something...// )

//обрабатывать новый action:
store.dispatch(action);

import { createStore } from 'redux';
const reducer = (state = 0, action) => { //принимает на вход текущий state, вторым аргументом принимает action, возвращает новый стейт по аналогии с setState в реакте
 switch (action.type) {//если наше действие 'INC' - вернуть state +1
    case 'INC':
      return state + 1;

    default: //если не распознали действие возвращаем state и его не изменяем
      return state;
  }
};
const store = createStore(reducer);
console.log(store.getState()); //выводим первоначальное состояние нашего приложения (у нас 0)
store.dispatch({type: 'INC'}); //просим store исполнить одно из действий, для этого вызываем dispatch и в этот метод мы передадим ту функцию (действие), которое мы хотим выполнить, в нашем случае с типом 'INC'
store.dispatch({type: 'INC'}); //выполняем то же действие для того чтобы увеличить счетчик на 2
console.log(store.getState());
//сперва вызываем store.getState() и получаем значение по умолчанию, которые мы присвоили в редюсере в стейт, затем мы дважды выполняем действие INC и блок кода <switch (action.type)...> вернет нам новый стейт и этот стейт обновится теперь уже внутри store. Теперь нам не нужно вручную создавать объект стейт и вручную передавать в него нужные действия, store за нас это все сделает.После того как мы выполним два инкремента мы снова получим текущий стейт из store

store.subscribe(() => { //store.subscribe позволяет получать нотификации когда store каким-либо образом изменился. Передаем сюда функцию, которая определяет что делать когда store изменился
  console.log(store.getState()); //после каждого изменения этот метод будет вызываться и печатать текущее значение в консоль
});
 */

/*108 Чистые (pure) функции 1-38
Функция-reducer это чистая функция. У чистой функции два условия.
1.Возвращаемое значение зависит только от аргументов.
>(a, b) => a > b ? a: b //чистая функция
>(a) => Math.random()*a // не чистая, потому что кроме аргументов используется генератор случайных чисел, который не был одним из аргументов этой функции.
//Для одинаковых аргументов чистая функция всегда будет вызывать одинаковые результаты.
>(a, b) => a > b ? a: b //чистая функция, результат будет одинаков независимо от того какие значения мы передадим в аргументы
>(a) => Math.random()*a // не чистая, результат зависит от случайности

2. У функции нет побочных эффектов.
//побочный эффект - любое изменение внешнего состояния (внешнего по отношению к функции). Функция может изменять только свое локальное состояние, только свои собственные локальные переменные. Изменение аргументов тоже считается побочным эффектом., поэтому чистая функция не может их изменять.
//Любые функции, которые модифицируют ДОМ, вызывают сервер, устанавливают тайм-ауты, используют случайные числа или текущее время - гарантировано не являются чистыми, поскольку они зависят от чистых ресурсов.
>const render = () => {document.getElementById('root').innerHTML = 'hi';} //не чистая, поскольку изменяет ноду из ДОМ-дерева, которую мы получили через глобальню переменную document
>const render = (el) => {el.innerHTML = 'hi'} //не чистая, побочный эффект - она модифицирует аргумент

Функция reducer должна соответствовать тем же требованиям, в reducer аргументы это текущий стейт и action и результат работы этой функции, то есть тот новый стейт, который мы возвращаем, он должен зависеть исключительно от предыдущего стейта и action и никаких других параметров, которые мы берем извне.
К примеру в функции reducer нам запрещено использовать текущее время, генератор случайных чисел или вызывать сервер. Любое из этих действий нарушит условие чистоты функции.
Второе условие тоже должно выполняться. У функции reducer не должно быть побочных эффектов, мы не должны устанавливать тайм-аут, устанавливать интервал, вызывать сервер или записывать значение в local store. Все это нарушает условие чистоты функции.

Reducer должен быть чистой функцией, поскольку:
Напрмер, если у нас есть набор, действий, которые выполняются в нашем приложении [a1, a2, a3, ... a150] и оно поломано, то есть одно из действий например где-то в середине привело к тому что store стал в неправильном состоянии. Если наш reducer чистая функция, то повторяя все эти действия (их можно лекго записать и затем просто переиграть заново), мы можем найти то самое действие внутри последовательности, которое вызвало проблему.
И нам будет несложно найти ту комбинацию стейта и екшена, которая ломает наш reducer. Другими словами каждый раз когда мы будем передавать в наш store одинаковую последовательность действий, если reducer это чистая функция, мы гарантированно получим на выходе одинаковый стейт, а это помогает в сложных приложениях, когда работа со стейтом и переход к другому при помощи екшена, а это то что делает наш reducer, это одна из основных частей нашего приложения и один из самых сложных блоков логики приложения.
Когда функция reducer это чистая функция, отлаживать такую логику намного проще.
 */

/*109 UI для Redux
В качестве UI может использоваться любая библиотека или фреймворк.
store.dispatch() используется для обновления состояния.
store.subscribe(...) используется для обновления UI.
 */

/*110 Действие с параметрами
Кроме типа, любое действие (action) может содержать дополнительную информацию:
store.dispatch({
  type: 'USER_LOGGED_IN',
  name: 'Arnold',
  role: 'admin'
});
Часто дополнительные параметры передают в поле payload.
 */

/*111 Action Creator
Action Creator - функция которая создает объекты action. Упрощает код:
const userLoggedIn = (name, role) => {
  return { type: 'USER_LOGGED_IN', name, role };
}
store.dispatch(userLoggedIn('Arnold', 'admin'));

//
const incDispatch = () => dispatch(inc());  //создаем функцию объединяя функции inc и dispatch, чтобы ниже использовать incDispatch вместо () => {dispatch(inc());}
const decDispatch = () => dispatch(dec());
const rndDispatch = (payload) => dispatch(rnd(payload)); //функция rnd принимает аргумент payload, передаем этот аргумент в action creator

document
    .getElementById('inc')
    .addEventListener('click', incDispatch);  //когда происходит клик - выполнить событие store.dispatch({type: 'INC'})
 */

/*112 Структура проекта
Есть несколько подходов к структуре Redux проекта.
Один из подходов - вынести reducer-функции и action creator функции в отдельные файлы или папки.
 */

/*113 bindActionCreators()
>bindActionCreators() - связывает функцию action creator с функцией dispatch()
const { add, remove } = bindActionCreators(actions);
>Созданные таким способом функции делают сразу два действия - создание действия (action) и отправка action в dispatch()

const { dispatch } = store; //деструктурируем dispatch из store чтобы ниже напрямую вызывать функцию dispatch вместо store.dispatch

const { inc, dec, rnd } = //bindActionCreators позволяет обернуть сразу несколько функций, вместо первого аргумента можно передать объект, ключи этого объекта - названия функций, которые мы хотим получить. //{ inc, dec, rnd } в объекте actions из actionCreator-a //используем их оригинальные имена как в AC
    bindActionCreators(actions, dispatch); //в качестве результата bindActionCreators вернет объект и ключи у этого объекта будут точно такими же, как у того объекта, который мы передали в bindActionCreators, а вместо оригинальных actionCreator-ов там будут их обернутые версии, те самые которые создают объект action и сразу передают его в функцию dispatch, получаем эти функции в { incDispatch, decDispatch, rndDispatch }

//
bindActionCreators работает точно так же как функция ниже, созданная для иллюстрации:
const bindActionCreator = (creator, dispatch) => (...args) => { //создаем функцию, которая связывает action creator и конкретную функцию dispatch, которая передаст наш action конкретному store. Первый аргумент - наш actionCreator, второй - dispatch//используем rest parametr ...args, собираем их в массив, поскольку мы не знаем сколько и какие могут быть аргументы
  dispatch(creator(...args)); //эта функция будет возвращать новую функцию, которая будет делать dispatch от creator //используем такой же синтаксис ...args, только теперь это будет деструктуризаия массива для того чтобы все эти аргументы в том же порядке нашему actionCreator
}; //таким образом мы создадим функцию, которая будет работать точно так же как actionCreator, но только она будет автоматически передавать созданный action в функцию dispatch

const incDispatch = bindActionCreator(inc, dispatch);  //создаем функцию объединяя функции inc и dispatch, чтобы ниже использовать incDispatch
 */

/*114 Использование React и Redux
React должен "знать" когда нужно обновлять компоненты (store.subscribe сообщает о том, что state обновился).
React компоненты должны быть как можно меньше связаны с Redux.
 */

/*115 react-redux и функция connect()
react-redux упрощает интеграцию ract + redux.
Provider делает store доступным всему дереву компонентов (через контекст).
connect() - компонент высшего порядка, который передает значения из store в компонент
const mapStateToProps = (state) => {
    return { name: state.name, age: state.age };
};

export default connect(mapStateToProps)(MyComponent);

export default connect(mapStateToProps)(Counter); //используем connect. это функция, которая возвращает функцию. передаются параметры конфигурации mapStateToProps. Затем туда передается Counter. Эта функция вернет новый компонент, который оборачивает Counter. Это компонент который связывает реакт и редакс
//Этот компонент будет брать из store те значение, что нужны Counter для работы и передавать их в Counter

//connect внутри себя создает новый компонент. Этот компонент оборачивает наш компонент Counter. Внутри этого компонента используя context API мы получаем доступ ко всему store. И для того чтобы каким-то образом получить значение из store и передать их в Counter мы используем функцию mapStateToProps.
// На вход этой функции передается текущий state из store. В reducer мы установили initialState 15, соответственно когда этот компонент получит store - он вызовет нашу функцию mapStateToProps, получит текущий state (у нас - 15), значение 15 мы присвоим свойство которое называется counter, это свойство получит компонент-обертка, который в свою очередь передаст это в компонент Counter.
 */

/*116 Функция mapDispatchToProps()
mapDispatchToProps - второй аргумент для функции connect():
const mapDispatchToProps = (dispatch) => {
    return {
        inc: () => dispatch({ type: 'INC' });
    };
};
Созданные функции будут переданы в компонент. Таким способом компонент может обновить состояние в store.

const mapDispatchToProps = (dispatch) => { // эта функция похожа на mapStateToProps, но вместо state работает с dispatch

    const { inc, dec, rnd } = bindActionCreators(actions, dispatch); //первым аргументом передаем объект с действиями, вторым - функцию dispatch. bindActionCreators вернет объект у которого точно такая же структура, как и у объекта actions, поэтому мы деструктурируем нужные функции и получим удобные константы

    return { //возвращаем объект, в качестве ключей у него будут те свойства, которые мы хотим присвоить нашему компоненту Counter, в качестве значений - те функции которые мы присваиваем
        inc, //inc: () => dispatch({type: 'INC'}) функция inc вызывает dispatch, в качестве объекта передаем ему action, у которого type: INC
        dec, //используем action creator, теперь в наш компонент передаются все 3 функции, которые ему нужны для работы
        rnd //благодаря bindActionCreators мы избавились от части кода и передадим inc, dec в точно таком виде как получили от bindActionCreators //теперь нам не нужно вызывать в явном виде dispatch
    }
};

export default connect(mapStateToProps, mapDispatchToProps)(Counter); //используем connect. это функция, которая возвращает функцию. передаются параметры конфигурации mapStateToProps. Затем туда передается Counter. Эта функция вернет новый компонент, который оборачивает Counter. Это компонент который связывает реакт и редакс
//Этот компонент будет брать из store те значение, что нужны Counter для работы и передавать их в Counter

//connect внутри себя создает новый компонент. Этот компонент оборачивает наш компонент Counter. Внутри этого компонента используя context API мы получаем доступ ко всему store. И для того чтобы каким-то образом получить значение из store и передать их в Counter мы используем функцию mapStateToProps.
// На вход этой функции передается текущий state из store. В reducer мы установили initialState 15, соответственно когда этот компонент получит store - он вызовет нашу функцию mapStateToProps, получит текущий state (у нас - 15), значение 15 мы присвоим свойство которое называется counter, это свойство получит компонент-обертка, который в свою очередь передаст это в компонент Counter.

//функцию mapDispatchToProps мы передаем в качестве второго аргумента в функцию connect
//функция коннект будет работать с нашей новой функцией mapDispatchToProps точно так же как она работает с mapStateToProps, только вместо аргумента она будет передавать функцию dispatch (это та самая функция, которая принимает новый action)
//и таким образом функция inc: () => dispatch({type: 'INC'}), которая внутри себя вызывает dispatch попадет к нашему объекту Counter в качестве свойства inc. Это свойство inc затем будет использовано как event-listener для кнопки increment.
// И когда пользователь нажмет на эту кнопку, произойдет сразу несколько действий: мы вызовем функцию inc, функция inc вызовет функцию dispatch и передаст в store новый action. Наша функция reducer получит это действие и обновит значение в store и после этого новое значение Counter снова придет в этот компонент благодаря функции mapStateToProps. Компонент получит новое свойство, отрисуется и покажет на экране новое значение счетчика

//функция connect это НОС, эта функция создает новый компонент-обертку, который отвечает за чтобы проинтегрировать наш компонент с redux store. Для того чтобы этот новый компонент работал ему нужно знать какие именно значения получить из store и как обработать функцию dispatch.
//Для этого у нас есть 2 функции, которые мы должны передать в коннект:
//1) mapStateToProps - она принимает на вход state и возвращает объект, ключи у которых это свойства, которые мы присвоим нашему компоненту, а значения это значаения из state, которые мы получим или вычислим
//2) mapDispatchToProps - работает так же как mapStateToProps, только вместо того чтобы использовать state она внутри себя использует функцию dispatch и в качестве значений мы передаем функции, которые наш компонент сможет использовать для того чтобы диспетчить события в store, то есть изменять глобальное состояние.
//Благодаря такой интеграции наш компонент ничего не знает про redux, этот компонент полностью независим от redux store.
 */

/*117 mapDispatchToProps в виде объекта
Action Creator не обязательно должен быть чистой функцией.
Если второй аргумент connect() это объект
connect(mapStateToProps, actions)(MyComponent);
То результат будет таким же, как для кода:
connect(
    mapStateToProps,
    (dispatch) => bindActionCreators(actions, dispatch))
(MyComponent)

const mapDispatchToProps = (dispatch) => { // эта функция похожа на mapStateToProps, но вместо state работает с dispatch
    return bindActionCreators(actions, dispatch); //первым аргументом передаем объект с действиями, вторым - функцию dispatch. bindActionCreators вернет объект у которого точно такая же структура, как и у объекта actions, поэтому мы деструктурируем нужные функции и получим удобные константы
}; //этот код берет те actionCreator-ы которые мы импортировали под теми же именами под которыми мы их импортировали. они связываются с функцией диспатч. Результирующие свойства присваиваются нашему объекту.
 */